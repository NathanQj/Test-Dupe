# coding: utf-8
# Part of CAPTIVEA. Odoo 11.

import pytz
import random

from datetime import datetime, time, timedelta

from odoo import fields, models, api

class Employee(models.Model):
    """Manage 'hr.employee' model. Overriding model."""
    _inherit = 'hr.employee'

    appointment_slots = fields.Integer(string='Number of Appointment Slots', default=1)

class CalendarAppointmentType(models.Model):
    """Manage 'calendar.appointment.type' model. Overriding model."""
    _inherit = "calendar.appointment.type"

    # OVERRIDING METHOD. CAPTIVEA #18001.
    def _slots_available(self, slots, first_day, last_day, employee=None):
        """ Fills the slot stucture with an available employee
            :param slots: slots structure generated by _slots_generate
            :param first_day: start datetime in UTC
            :param last_day: end datetime in UTC
            :param employee: if set, only consider this employee
                             if not set, consider all employees assigned to this appointment type
        """

        def is_work_available(start_dt, end_dt, intervals):
            """ check if the slot is contained in the employee's work hours (defined by intervals)
            """
            def find_start_index():
                """ find the highest index of intervals for which the start_date (element [0]) is before (or at) start_dt
                """
                def recursive_find_index(lower_bound, upper_bound):
                    if upper_bound - lower_bound <= 1:
                        if intervals[upper_bound][0] <= start_dt:
                            return upper_bound
                        return lower_bound
                    index = (upper_bound + lower_bound) // 2
                    if intervals[index][0] <= start_dt:
                        return recursive_find_index(index, upper_bound)
                    else:
                        return recursive_find_index(lower_bound, index)

                if start_dt <= intervals[0][0] - tolerance:
                    return -1
                if end_dt >= intervals[-1][1] + tolerance:
                    return -1
                return recursive_find_index(0, len(intervals) - 1)

            if not intervals:
                return False

            tolerance = timedelta(minutes=1)
            start_index = find_start_index()
            if start_index != -1:
                for index in range(start_index, len(intervals)):
                    if intervals[index][1] >= end_dt - tolerance:
                        return True
                    if len(intervals) == index + 1 or intervals[index + 1][0] - intervals[index][1] > tolerance:
                        return False
            return False

        def is_calendar_available(slot, events, employee):
            """ Returns True if the given slot doesn't collide with given events for the employee
            """
            start_dt_string = slot['UTC'][0]
            end_dt_string = slot['UTC'][1]
            employee_tz = pytz.timezone(employee.user_id.tz or self.sudo().env.user.tz or slot['slot'].appointment_type_id.appointment_tz or 'UTC')

            # CAPTIVEA #18001
            n_busy = 0
            # END CAPTIVEA #18001

            # BEFORE CAPTIVEA #18001
            # END BEFORE CAPTIVEA #18001

            for ev in events.filtered(lambda ev: ev.start < end_dt_string and ev.stop > start_dt_string):
                if ev.allday:
                    # allday events are considered to take the whole day in the related employee's timezone
                    ev_start_dt = datetime.combine(fields.Date.from_string(ev.start_date), time.min)
                    ev_stop_dt = datetime.combine(fields.Date.from_string(ev.stop_date), time.max)
                    ev_start_dt = employee_tz.localize(ev_start_dt).astimezone(pytz.UTC).replace(tzinfo=None)
                    ev_stop_dt = employee_tz.localize(ev_stop_dt).astimezone(pytz.UTC).replace(tzinfo=None)
                    if ev_start_dt < slot['UTC'][1] and ev_stop_dt > slot['UTC'][0]:

                        # CAPTIVEA #18001
                        n_busy += 1
                        if n_busy >= employee.appointment_slots:
                            return False
                        # END CAPTIVEA #18001

                        # BEFORE CAPTIVEA #18001
                        # return False
                        # END BEFORE CAPTIVEA #18001

                elif ev.start_datetime < end_dt_string and ev.stop_datetime > start_dt_string:

                    # CAPTIVEA #18001
                    n_busy += 1
                    if n_busy >= employee.appointment_slots:
                        return False
                    # END CAPTIVEA #18001

                    # BEFORE CAPTIVEA #18001
                    # return False
                    # END BEFORE CAPTIVEA #18001

            return True

        workhours = {}
        meetings = {}

        # With context will be used in resource.calendar to force the referential user
        # for work interval computing to the *user linked to the employee*
        available_employees = [emp.with_context({'tz': emp.user_id.tz}) for emp in (employee or self.employee_ids)]
        random.shuffle(available_employees)
        for slot in slots:
            for emp_pos, emp in enumerate(available_employees):
                if emp_pos not in workhours:
                    workhours[emp_pos] = [
                        (interval[0].astimezone(pytz.UTC).replace(tzinfo=None),
                         interval[1].astimezone(pytz.UTC).replace(tzinfo=None))
                        for interval in emp.resource_calendar_id._work_intervals(
                            first_day, last_day, resource=emp.resource_id,
                        )
                    ]

                if is_work_available(slot['UTC'][0], slot['UTC'][1], workhours[emp_pos]):
                    if emp_pos not in meetings:
                        # note: no check is made on the attendee's status (accepted/declined/...)
                        meetings[emp_pos] = self.env['calendar.event'].search([
                            ('partner_ids.user_ids', '=', emp.user_id.id),
                            ('start', '<', fields.Datetime.to_string(last_day.replace(hour=23, minute=59, second=59))),
                            ('stop', '>', fields.Datetime.to_string(first_day.replace(hour=0, minute=0, second=0)))
                        ])

                    if is_calendar_available(slot, meetings[emp_pos], emp):
                        slot['employee_id'] = emp
                        break
